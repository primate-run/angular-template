declare const _default: {
    every: {
        string: <T>(xs: T[]) => T[];
        number: <T>(xs: T[]) => T[];
        bigint: <T>(xs: T[]) => T[];
        boolean: <T>(xs: T[]) => T[];
        symbol: <T>(xs: T[]) => T[];
        undefined: <T>(xs: T[]) => T[];
        object: <T>(xs: T[]) => T[];
        function: <T>(xs: T[]) => T[];
        false: <T>(xs: T[]) => T[];
        true: <T>(xs: T[]) => T[];
        map: <T>(xs: T[]) => T[];
        null: <T>(xs: T[]) => T[];
        array: <T>(xs: T[]) => T[];
        date: <T>(xs: T[]) => T[];
        dict: <T>(xs: T[]) => T[];
        error: <T>(xs: T[]) => T[];
        finite: <T>(xs: T[]) => T[];
        int: <T>(xs: T[]) => T[];
        nan: <T>(xs: T[]) => T[];
        newable: <T>(xs: T[]) => T[];
        nullish: <T>(xs: T[]) => T[];
        promise: <T>(xs: T[]) => T[];
        regexp: <T>(xs: T[]) => T[];
        safeint: <T>(xs: T[]) => T[];
        set: <T>(xs: T[]) => T[];
        uint: <T>(xs: T[]) => T[];
        url: <T>(xs: T[]) => T[];
        empty: <T>(xs: T[]) => T[];
        nonempty: <T>(xs: T[]) => T[];
        defined: <T>(xs: T[]) => T[];
        uuid: <T>(xs: T[]) => T[];
    } & {
        instance: <T extends import("@rcompat/type").Newable>(xs: unknown[], N: T, error?: Error | string) => InstanceType<T>[];
    };
    maybe: {
        string: <T>(x: T) => T;
        number: <T>(x: T) => T;
        bigint: <T>(x: T) => T;
        boolean: <T>(x: T) => T;
        symbol: <T>(x: T) => T;
        undefined: <T>(x: T) => T;
        object: <T>(x: T) => T;
        function: <T>(x: T) => T;
        false: <T>(x: T) => T;
        true: <T>(x: T) => T;
        map: <T>(x: T) => T;
        null: <T>(x: T) => T;
        array: <T>(x: T) => T;
        date: <T>(x: T) => T;
        dict: <T>(x: T) => T;
        error: <T>(x: T) => T;
        finite: <T>(x: T) => T;
        int: <T>(x: T) => T;
        nan: <T>(x: T) => T;
        newable: <T>(x: T) => T;
        nullish: <T>(x: T) => T;
        promise: <T>(x: T) => T;
        regexp: <T>(x: T) => T;
        safeint: <T>(x: T) => T;
        set: <T>(x: T) => T;
        uint: <T>(x: T) => T;
        url: <T>(x: T) => T;
        empty: <T>(x: T) => T;
        nonempty: <T>(x: T) => T;
        defined: <T>(x: T) => T;
        uuid: <T>(x: T) => T;
    } & {
        instance: <T extends import("@rcompat/type").Newable>(x: unknown, N: T, error?: Error | string) => InstanceType<T> | null | undefined;
    };
    bigint: (x: unknown, error?: Error | string) => bigint;
    boolean: (x: unknown, error?: Error | string) => boolean;
    function: (x: unknown, error?: Error | string) => import("@rcompat/type").UnknownFunction;
    number: (x: unknown, error?: Error | string) => number;
    string: (x: unknown, error?: Error | string) => string;
    symbol: (x: unknown, error?: Error | string) => symbol;
    undefined: (x: unknown, error?: Error | string) => undefined;
    array: (x: unknown, error?: Error | string) => unknown[];
    date: (x: unknown, error?: Error | string) => Date;
    dict: <U>(x: U, error?: Error | string) => U extends import("@rcompat/type").Dict ? U : import("@rcompat/type").Dict;
    error: (x: unknown, error?: Error | string) => Error;
    false: (x: unknown, error?: Error | string) => false;
    finite: (x: unknown, error?: Error | string) => number | bigint;
    int: (x: unknown, error?: Error | string) => number | bigint;
    map: (x: unknown, error?: Error | string) => Map<unknown, unknown>;
    nan: (x: unknown, error?: Error | string) => number;
    newable: (x: unknown, error?: Error | string) => import("@rcompat/type").Newable;
    null: (x: unknown, error?: Error | string) => null;
    nullish: (x: unknown, error?: Error | string) => import("@rcompat/type").Nullish;
    object: (x: unknown, error?: Error | string) => object;
    promise: (x: unknown, error?: Error | string) => Promise<unknown>;
    regexp: (x: unknown, error?: Error | string) => RegExp;
    safeint: (x: unknown, error?: Error | string) => number;
    set: (x: unknown, error?: Error | string) => Set<unknown>;
    true: (x: unknown, error?: Error | string) => true;
    uint: (x: unknown, error?: Error | string) => number | bigint;
    url: (x: unknown, error?: Error | string) => URL;
    empty: <T>(x: T, error?: Error | string) => T;
    nonempty: <T>(x: T, error?: Error | string) => T;
    defined: <T>(x: T, error?: Error | string) => NonNullable<T>;
    instance: <T extends import("@rcompat/type").Newable>(x: unknown, N: T, error?: Error | string) => InstanceType<T>;
    uuid: (x: unknown, error?: Error | string) => string;
};
export default _default;
//# sourceMappingURL=assert.d.ts.map